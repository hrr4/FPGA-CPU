library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity UART_Control is
  generic (
    WORD_SZ    : natural;
    PAUSE_TIME : natural
    );
  port(
    clock    : in  std_logic;
    word     : in  unsigned(WORD_SZ-1 downto 0);
    data_out : out std_logic_vector(7 downto 0)
    );
end entity;

architecture UART_Control of UART_Control is
  component uart is
    port(
      clock    : in  std_logic;
      byte_in  : out std_logic_vector(7 downto 0);
      byte_out : in  std_logic_vector(7 downto 0);
      bit_out  : out std_logic;
      bit_in   : in  std_logic;
      transmit : in  std_logic
      );
  end component;

  type state_t is (idle, init, fire, done, reset);

  signal state        : state_t              := idle;
  signal transmit     : std_logic;
  signal transmit_buf : unsigned(WORD_SZ-1 downto 0);
  signal send_byte    : unsigned(7 downto 0) := (others => '0');
  signal can_send     : std_logic            := '0';

  constant MAX_ROTATE : natural := WORD_SZ / send_byte'length;
begin
--
--  uart_out : uart port map(clock, send_byte, transmit);
--
--  process (clock, word)
--    variable transmit_count : unsigned(10 downto 0);
--  begin
--    if rising_edge(clock) then
--
--      case state is
--        when idle =>
--        when init =>                    -- Good
--          state          <= transmit;
--          transmit_count <= (others => '0');
--        when fire =>                    -- Reset the transmission (somehow)
--          -- Hold transmit low for a bit, so we can stop transmission between bytes.
--          -- Count up to the largest value we can have, only then modify the buffer.
--          transmit_count <= transmit_count + 1;
--
--          if transmit_count >= resize("1", transmit_count'length) then
--            transmit_buf <= transmit_buf ror send_byte'length;
--          --transmit_count <= (others => '0');
--          end if;
--
--        when done =>
--          transmit <= '0';
--          state    <= idle;
--        when reset =>
--          state <= init;
--      end case;
--    end if;
--  end process;
--
--  process (state)
--  begin
--    transmit <= '0';
--
--
--    case state is
--      when idle =>
--        transmit <= '0';
--
--      when init =>
--
--      when fire =>
--        transmit <= '1';
--
--        if transmit then
--          send_byte <= transmit_buf(7 downto 0);
--        end if;
--      when done =>
--      -- Go back to idle
--      when reset =>
--        -- Go back to init
--
--    end case;
--  end process;

end architecture;
