library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;

use work.helpers.all;
use work.instr_set.all;

entity Execute is
  port(
    clock                      : in     std_logic;
    instr                      : in     unsigned(15 downto 0);
    rdata1, rdata2, rdata3     : in     unsigned(31 downto 0);
    pc                         : in     unsigned(31 downto 1);
    defer_load                 : buffer std_logic;
    branch_value               : out    signed(10 downto 0);
    Nflag, Zflag, Cflag, Vflag : buffer std_logic;
    wadr                       : buffer unsigned(3 downto 0);
    wdata                      : buffer unsigned(31 downto 0);
    rf_wr                      : buffer std_logic;
    dm_addr                    : out    unsigned(31 downto 2);
    dm_data_wr                 : out    unsigned(31 downto 0);
    dm_we                      : out    std_logic
    );
end Execute;

architecture Execute of Execute is
  signal Ztmp, Ctmp, Vtmp, Ntmp : std_logic;
begin

  process (instr, rdata1, rdata2, rdata3, pc, Nflag, Zflag, Cflag, Vflag)
    variable condition   : unsigned(3 downto 0);
    variable take_branch : boolean;
    variable sum         : unsigned(32 downto 0);
    variable flags       : flags_bv;

    variable wadr_tmp  : unsigned(3 downto 0)  := (others => '0');
    variable wdata_tmp : unsigned(31 downto 0) := (others => '0');
    variable rf_wr_tmp : std_logic             := '0';

    variable dm_addr_tmp    : unsigned(31 downto 2) := (others => '0');
    variable dm_data_wr_tmp : unsigned(31 downto 0) := (others => '0');
    variable dm_we_tmp      : std_logic             := '0';

    variable defer_tmp : std_logic;

  begin
    rf_wr        <= '0';
    branch_value <= "00000000001";

    defer_load <= '0';
    defer_tmp  := '0';

    Ztmp <= '0';
    Ntmp <= '0';
    Ctmp <= '0';
    Vtmp <= '0';

    --wadr_tmp := wadr;
    --wdata_tmp := wdata;
    --rf_wr_tmp := rf_wr;

    --dm_addr_tmp    := dm_addr;
    --dm_data_wr_tmp := dm_data_wr;
    --dm_we_tmp      := dm_we;

    if instr /= NOP then
      if xor_reduce(std_logic_vector(instr)) /= 'U' and xor_reduce(std_logic_vector(instr)) /= 'X' then
        -- Deduce type of instruction
        -- Feed to that function
        -- Further deduction required within function
        -- Return flags if necessary.

        flags := Nflag & Zflag & Cflag & Vflag;

        case instr(15 downto 13) is
          when "000" =>
            alu(instr, flags, rdata1, rdata2, rdata3, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);

          when "001" =>                 -- Move/Compare/add/sub #Imm8
            alu_imm8(instr, flags, rdata1, rdata2, rdata3, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);

          when "010" =>
            if instr(12) = '0' then
              if instr(11 downto 10) = "00" then     -- ALU operations
                alu(instr, flags, rdata1, rdata2, rdata3, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);
              elsif instr(11 downto 10) = "01" then  -- hi reg operations / branch exchange
                hi_reg_bx(instr, flags, rdata1, rdata2, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);
              end if;

              if instr(11) = '1' then   -- PC-relative load.
                pc_rel_load(instr, pc, rdata2, rdata3, dm_addr_tmp, dm_we_tmp, defer_tmp);
              end if;
            else
              if instr(9) = '0' then    -- Load/store register offset
                load_store_offset(instr, rdata1, rdata2, rdata3, dm_addr_tmp, dm_we_tmp, dm_data_wr_tmp, defer_tmp);
              else                      --Load/store sign-extend byte/halfword
                load_store_sign(instr, rdata1, rdata2, rdata3, dm_addr_tmp, dm_we_tmp, dm_data_wr_tmp, defer_tmp);
              end if;
            end if;

          when "011" | "100" =>
            -- Load/store immediate offset or l/s halfword
            if instr(12) = '0' then
              load_store_offset(instr, rdata1, rdata2, rdata3, dm_addr_tmp, dm_we_tmp, dm_data_wr_tmp, defer_tmp);
            else                        --SP relative load/store
              load_store_sp(instr, rdata3, dm_addr_tmp, dm_we_tmp, dm_data_wr_tmp, defer_tmp);
            end if;

            --when "100" =>
            --  if instr(12) = '0' then
            --    -- load/store halfword
            --    else
            --  -- SP-relative load/store
            --  end if;

          when "101" =>
            if instr(12) = '0' then     -- Load address
              load_address(instr, pc, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);
            elsif instr(12) = '1' then
              if instr(10) = '0' then
                offset_sp_sign(instr, rdata1, rdata2, wadr_tmp, wdata_tmp, rf_wr_tmp, flags);
              else
              --Push/pop regs
              end if;
            end if;

          when "110" =>
            if instr(12) = '0' then
              -- Multiple load/store
              else
              if instr(11 downto 8) = "1111" then
                -- Software Interrupt
                else
                  -- Conditional Branch
                  take_branch := branch(instr, flags);

                if take_branch then
                  branch_value <= resize(signed(instr(7 downto 0)), 11);
                end if;

              end if;
            end if;

          when "111" =>
            if instr(12) = '0' then
              -- Unconditional Branch
              branch_value <= signed(instr(10 downto 0));
            else
            -- Long branch w/ Link
            end if;

          when others =>
            branch_value <= (others => '0');
        end case;

        wadr  <= wadr_tmp;
        wdata <= wdata_tmp;
        rf_wr <= rf_wr_tmp;

        dm_addr    <= dm_addr_tmp;
        dm_data_wr <= dm_data_wr_tmp;
        dm_we      <= dm_we_tmp;

        defer_load <= defer_tmp;

        Ntmp <= flags(3);
        Ztmp <= flags(2);
        Ctmp <= flags(1);
        Vtmp <= flags(0);

      end if;
    --else
    --  branch_value <= (others => '0');
    end if;
  end process;


  -- store flags
  process (clock)
  begin
    if rising_edge(clock) then
      Zflag <= Ztmp;
      Cflag <= Ctmp;
      Nflag <= Ntmp;
      Vflag <= Vtmp;
    end if;
  end process;

end Execute;
